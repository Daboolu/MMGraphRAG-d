<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>çŸ¥è¯†å›¾è°±å¯è§†åŒ– - MMGraphRAG</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap"
        rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/graphology@0.25.4/dist/graphology.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sigma@2.4.0/build/sigma.min.js"></script>
    <style>
        :root {
            --bg-primary: #0f0a1a;
            --bg-secondary: #1a1025;
            --surface-card: rgba(40, 30, 60, 0.6);
            --surface-glass-hover: rgba(167, 139, 250, 0.1);
            --border-subtle: rgba(130, 100, 180, 0.25);
            --border-glow: rgba(167, 139, 250, 0.5);
            --text-primary: #f0f0f5;
            --text-secondary: #a0a0b0;
            --text-tertiary: #6b6b7b;
            --neon-purple: #a78bfa;
            --neon-cyan: #22d3ee;
            --gradient-primary: linear-gradient(135deg, #a78bfa 0%, #22d3ee 100%);
            --glow-purple: 0 0 30px rgba(167, 139, 250, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, #1a0f2e 50%, #0f1a2e 100%);
            color: var(--text-primary);
            min-height: 100vh;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px 0;
            margin-bottom: 20px;
            position: relative;
        }

        h1 {
            font-size: 32px;
            font-weight: 700;
            background: var(--gradient-primary);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: 1px;
        }

        .stats-row {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: var(--surface-card);
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            padding: 16px;
            text-align: center;
            flex: 1;
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            border-color: var(--border-glow);
            box-shadow: var(--glow-purple);
        }

        .stat-value {
            font-size: 24px;
            font-weight: 800;
            background: var(--gradient-primary);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .stat-label {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .toolbar {
            display: flex;
            gap: 16px;
            margin-bottom: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .search-box {
            flex: 1;
            min-width: 250px;
            position: relative;
        }

        .search-input {
            width: 100%;
            padding: 10px 16px 10px 40px;
            background: var(--surface-card);
            border: 1px solid var(--border-subtle);
            border-radius: 10px;
            color: var(--text-primary);
            font-size: 14px;
        }

        .search-input:focus {
            border-color: var(--neon-purple);
            outline: none;
        }

        .search-icon {
            position: absolute;
            left: 14px;
            top: 50%;
            transform: translateY(-50%);
            opacity: 0.5;
        }

        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border-subtle);
            border-radius: 10px;
            margin-top: 8px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 100;
            display: none;
        }

        .search-results.show {
            display: block;
        }

        .search-result-item {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-subtle);
            cursor: pointer;
            transition: background 0.2s;
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-result-item:hover {
            background: var(--surface-glass-hover);
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-secondary);
            font-size: 14px;
            cursor: pointer;
        }

        .checkbox-label input {
            width: 18px;
            height: 18px;
            accent-color: var(--neon-purple);
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 20px;
            flex: 1;
            min-height: 0;
        }

        .graph-container {
            background: var(--surface-card);
            border: 1px solid var(--border-subtle);
            border-radius: 16px;
            overflow: hidden;
            position: relative;
        }

        #graph-canvas {
            width: 100%;
            height: 100%;
        }

        .graph-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: var(--text-secondary);
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid var(--border-subtle);
            border-top-color: var(--neon-purple);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .graph-controls {
            position: absolute;
            bottom: 16px;
            right: 16px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-btn {
            width: 40px;
            height: 40px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .control-btn:hover {
            background: var(--surface-glass-hover);
            border-color: var(--neon-purple);
        }

        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .panel-section {
            background: var(--surface-card);
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            padding: 16px;
        }

        .panel-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text-primary);
        }

        .legend-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 200px;
            overflow-y: auto;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            flex-shrink: 0;
            cursor: pointer;
        }

        .legend-count {
            margin-left: auto;
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
        }

        .detail-panel {
            flex: 1;
            overflow-y: auto;
        }

        .detail-field {
            margin-bottom: 12px;
        }

        .detail-label {
            font-size: 11px;
            color: var(--text-tertiary);
            margin-bottom: 4px;
            text-transform: uppercase;
        }

        .detail-value {
            color: var(--text-primary);
            word-break: break-word;
            font-size: 13px;
            line-height: 1.6;
        }

        .entity-type-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: 500;
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>çŸ¥è¯†å›¾è°±å¯è§†åŒ–</h1>
        </header>

        <div class="stats-row">
            <div class="stat-card">
                <div class="stat-value" id="stat-nodes">-</div>
                <div class="stat-label">èŠ‚ç‚¹æ•°</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="stat-edges">-</div>
                <div class="stat-label">è¾¹æ•°</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="stat-types">-</div>
                <div class="stat-label">å®ä½“ç±»å‹</div>
            </div>
        </div>

        <div class="toolbar">
            <div class="search-box">
                <span class="search-icon">ğŸ”</span>
                <input type="text" class="search-input" id="search-input" placeholder="æœç´¢èŠ‚ç‚¹...">
                <div class="search-results" id="search-results"></div>
            </div>
            <div class="search-box" style="flex: 2;">
                <span class="search-icon">ğŸ’¡</span>
                <input type="text" class="search-input" id="retrieve-input" placeholder="è¾“å…¥é—®é¢˜è¿›è¡Œæ£€ç´¢ï¼Œé«˜äº®ç›¸å…³å­å›¾..."
                    style="padding-left: 40px;">
                <button id="retrieve-btn"
                    style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); padding: 6px 16px; background: var(--gradient-primary); border: none; border-radius: 8px; color: white; cursor: pointer; font-size: 12px;">æ£€ç´¢</button>
            </div>
            <label class="checkbox-label">
                <input type="checkbox" id="show-labels" checked>
                æ˜¾ç¤ºèŠ‚ç‚¹åç§°
            </label>
            <button id="clear-retrieve-btn"
                style="padding: 8px 16px; background: transparent; border: 1px solid var(--border-subtle); border-radius: 8px; color: var(--text-secondary); cursor: pointer; font-size: 12px; display: none;">æ¸…é™¤é«˜äº®</button>
        </div>

        <div class="main-content">
            <div class="graph-container">
                <div id="graph-canvas"></div>
                <div class="graph-loading" id="graph-loading">
                    <div class="spinner"></div>
                    <div>æ­£åœ¨åŠ è½½çŸ¥è¯†å›¾è°±...</div>
                </div>
                <div class="graph-controls">
                    <button class="control-btn" id="zoom-in" title="æ”¾å¤§">+</button>
                    <button class="control-btn" id="zoom-out" title="ç¼©å°">âˆ’</button>
                    <button class="control-btn" id="zoom-reset" title="é‡ç½®">âŸ²</button>
                </div>
            </div>

            <div class="side-panel">
                <div class="panel-section">
                    <div class="panel-title">å®ä½“ç±»å‹å›¾ä¾‹</div>
                    <div class="legend-list" id="legend-list">
                        <div style="color: var(--text-tertiary);">åŠ è½½ä¸­...</div>
                    </div>
                </div>
                <div class="panel-section detail-panel">
                    <div class="panel-title">è¯¦æƒ…</div>
                    <div class="detail-content" id="detail-content">
                        <div style="color: var(--text-tertiary);">ç‚¹å‡»èŠ‚ç‚¹æˆ–è¾¹æŸ¥çœ‹è¯¦æƒ…</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // === é¢œè‰²é…ç½® ===
        const typeColors = {
            'PERSON': '#f472b6', 'TECHNOLOGY': '#60a5fa', 'EVENT': '#34d399',
            'ORGANIZATION': '#fbbf24', 'GEO': '#a78bfa', 'CONCEPT': '#fb923c',
            'FIGURE': '#14b8a6', 'ORI_IMG': '#f87171', 'IMG': '#f87171',
            'PRODUCT': '#22d3ee', 'LOCATION': '#c084fc', 'METHOD': '#4ade80',
            'DATE': '#facc15', 'MONEY': '#4ade80', 'QUANTITY': '#818cf8',
            'default': '#94a3b8'
        };

        const colorPalette = [
            '#f472b6', '#60a5fa', '#34d399', '#fbbf24', '#a78bfa', '#fb923c',
            '#14b8a6', '#22d3ee', '#c084fc', '#4ade80', '#818cf8', '#fb7185'
        ];

        // === å…¨å±€çŠ¶æ€ ===
        let graphData = null;
        let sigmaInstance = null;
        let graph = null;
        let selectedNode = null;
        let originalNodeAttrs = {};
        let hiddenTypes = new Set();
        let colorIndex = 0;

        // === å·¥å…·å‡½æ•° ===
        function getTypeColor(type) {
            if (typeColors[type]) return typeColors[type];
            const color = colorPalette[colorIndex % colorPalette.length];
            typeColors[type] = color;
            colorIndex++;
            return color;
        }

        function cleanNodeId(id) {
            return id.replace(/^["']|["']$/g, '');
        }

        // === å›¾è°±åŠ è½½ ===
        async function loadGraph() {
            const loading = document.getElementById('graph-loading');
            loading.style.display = 'block';

            try {
                const resp = await fetch('/api/graph/content?limit=5000');
                const data = await resp.json();

                if (data.success) {
                    graphData = data;
                    renderGraph(data);
                    renderLegend(data.entity_types);
                    document.getElementById('stat-nodes').textContent = data.total_nodes.toLocaleString();
                    document.getElementById('stat-edges').textContent = data.total_edges.toLocaleString();
                    document.getElementById('stat-types').textContent = Object.keys(data.entity_types).length;
                } else {
                    loading.innerHTML = `<div>âŒ ${data.error}</div>`;
                }
            } catch (error) {
                loading.innerHTML = `<div>âŒ åŠ è½½å¤±è´¥: ${error.message}</div>`;
            }
        }

        // === å›¾è°±æ¸²æŸ“ ===
        function renderGraph(data) {
            const container = document.getElementById('graph-canvas');
            const loading = document.getElementById('graph-loading');

            if (sigmaInstance) {
                sigmaInstance.kill();
                sigmaInstance = null;
            }

            graph = new graphology.Graph();

            // å¸ƒå±€å‚æ•°
            const nodeCount = data.nodes.length;

            // åŠ¨æ€è®¡ç®—å¤§å°
            let nodeSize, edgeSize;
            if (nodeCount < 100) {
                nodeSize = 8;
                edgeSize = 2;
            } else if (nodeCount < 500) {
                nodeSize = 6;
                edgeSize = 1.5;
            } else if (nodeCount < 2000) {
                nodeSize = 4;
                edgeSize = 0.8;
            } else {
                nodeSize = 2;
                edgeSize = 0.3;
            }

            const radius = Math.sqrt(nodeCount) * 30;

            // æ·»åŠ èŠ‚ç‚¹
            data.nodes.forEach((node, i) => {
                const angle = (i / nodeCount) * Math.PI * 2;
                const r = radius * (0.3 + Math.random() * 0.7);
                const type = node.entity_type || 'default';
                const color = getTypeColor(type);

                graph.addNode(node.id, {
                    x: r * Math.cos(angle) + (Math.random() - 0.5) * 50,
                    y: r * Math.sin(angle) + (Math.random() - 0.5) * 50,
                    size: nodeSize,
                    originalSize: nodeSize, // ä¿å­˜åŸå§‹å¤§å°
                    color: color,
                    originalColor: color,
                    label: cleanNodeId(node.id),
                    entityType: type,
                    description: node.description || ''
                });
            });

            // æ·»åŠ è¾¹
            data.edges.forEach((edge, i) => {
                if (graph.hasNode(edge.source) && graph.hasNode(edge.target)) {
                    try {
                        const sourceAttrs = graph.getNodeAttributes(edge.source);
                        const edgeColor = sourceAttrs.color;

                        graph.addEdge(edge.source, edge.target, {
                            id: `e${i}`,
                            size: edgeSize,
                            originalSize: edgeSize,
                            color: edgeColor,
                            originalColor: edgeColor,
                            description: edge.description || ''
                        });
                    } catch (e) { }
                }
            });

            loading.style.display = 'none';

            // åˆ›å»º Sigma å®ä¾‹
            const showLabels = document.getElementById('show-labels').checked && nodeCount < 500;
            if (nodeCount >= 500) {
                document.getElementById('show-labels').checked = false;
            }

            sigmaInstance = new Sigma(graph, container, {
                renderLabels: showLabels,
                minCameraRatio: 0.0001,
                maxCameraRatio: 10,
                enableEdgeClickEvents: true,
                enableEdgeHoverEvents: false,
                labelRenderedSizeThreshold: 2,
                zIndex: true,
                labelColor: { attribute: 'color' }
            });

            // èŠ‚ç‚¹ç‚¹å‡»
            sigmaInstance.on('clickNode', (event) => {
                selectNode(event.node);
            });

            // è¾¹ç‚¹å‡»
            sigmaInstance.on('clickEdge', (event) => {
                clearSelection();
                const edgeId = event.edge;
                const attrs = graph.getEdgeAttributes(edgeId);
                const source = graph.source(edgeId);
                const target = graph.target(edgeId);
                graph.setEdgeAttribute(edgeId, 'color', '#ffffff');
                sigmaInstance.refresh();
                showEdgeDetail(source, target, attrs);
            });

            // ç‚¹å‡»ç©ºç™½
            sigmaInstance.on('clickStage', () => {
                clearSelection();
            });
        }

        // === é€‰ä¸­èŠ‚ç‚¹ ===
        function selectNode(nodeId) {
            clearSelection();

            selectedNode = nodeId;
            const attrs = graph.getNodeAttributes(nodeId);

            // è·å–ç›¸è¿èŠ‚ç‚¹
            const connectedNodes = new Set([nodeId]);
            graph.forEachEdge(nodeId, (edge, attrs, source, target) => {
                connectedNodes.add(source);
                connectedNodes.add(target);
            });

            // ä¿å­˜åŸå§‹å±æ€§å¹¶æ·¡åŒ–éç›¸å…³èŠ‚ç‚¹
            graph.forEachNode((nid, nattrs) => {
                if (!originalNodeAttrs[nid]) {
                    originalNodeAttrs[nid] = {
                        size: nattrs.size,
                        color: nattrs.color,
                        label: nattrs.label
                    };
                }
                if (!connectedNodes.has(nid)) {
                    graph.setNodeAttribute(nid, 'color', '#3d3654');
                    graph.setNodeAttribute(nid, 'label', '');
                }
            });

            // æ·¡åŒ–éç›¸å…³è¾¹
            graph.forEachEdge((edge, eattrs, source, target) => {
                if (!connectedNodes.has(source) || !connectedNodes.has(target)) {
                    graph.setEdgeAttribute(edge, 'color', '#2d2644');
                } else if (source === nodeId || target === nodeId) {
                    graph.setEdgeAttribute(edge, 'color', attrs.originalColor || attrs.color);
                }
            });

            // é«˜äº®é€‰ä¸­èŠ‚ç‚¹
            const highlightSize = Math.min(attrs.size * 3, attrs.size + 8);
            graph.setNodeAttribute(nodeId, 'size', highlightSize);
            graph.setNodeAttribute(nodeId, 'zIndex', 1000);

            // ç›¸å…³èŠ‚ç‚¹è®¾ç½®è¾ƒé«˜ zIndex
            connectedNodes.forEach(nid => {
                if (nid !== nodeId && graph.hasNode(nid)) {
                    graph.setNodeAttribute(nid, 'zIndex', 500);
                    graph.setNodeAttribute(nid, 'label', cleanNodeId(nid));
                }
            });

            // ç›¸å…³è¾¹è®¾ç½®åˆ°é¡¶å±‚
            graph.forEachEdge(nodeId, (edge) => {
                graph.setEdgeAttribute(edge, 'zIndex', 500);
            });

            sigmaInstance.refresh();
            showNodeDetail(nodeId, attrs);
        }

        // === æ¸…é™¤é€‰ä¸­ ===
        function clearSelection() {
            if (!graph || !sigmaInstance) return;

            Object.keys(originalNodeAttrs).forEach(nid => {
                if (graph.hasNode(nid)) {
                    const orig = originalNodeAttrs[nid];
                    graph.setNodeAttribute(nid, 'size', orig.size);
                    graph.setNodeAttribute(nid, 'color', orig.color);
                    graph.setNodeAttribute(nid, 'zIndex', 0);
                    if (orig.label !== undefined) {
                        graph.setNodeAttribute(nid, 'label', orig.label);
                    }
                }
            });

            graph.forEachEdge((edge) => {
                const edgeAttrs = graph.getEdgeAttributes(edge);
                if (edgeAttrs.originalColor) {
                    graph.setEdgeAttribute(edge, 'color', edgeAttrs.originalColor);
                }
                if (edgeAttrs.originalSize) {
                    graph.setEdgeAttribute(edge, 'size', edgeAttrs.originalSize);
                }
            });

            selectedNode = null;
            originalNodeAttrs = {};
            sigmaInstance.refresh();
        }

        // === æ¸²æŸ“å›¾ä¾‹ ===
        function renderLegend(entityTypes) {
            const container = document.getElementById('legend-list');
            const sortedTypes = Object.entries(entityTypes).sort((a, b) => b[1] - a[1]);

            container.innerHTML = sortedTypes.map(([type, count]) => {
                const isHidden = hiddenTypes.has(type);
                const color = isHidden ? '#666666' : getTypeColor(type);
                return `
                    <div class="legend-item" data-type="${type}">
                        <div class="legend-color" style="background: ${color}; opacity: ${isHidden ? 0.5 : 1};" title="ç‚¹å‡»æ˜¾ç¤º/éšè—"></div>
                        <span style="opacity: ${isHidden ? 0.5 : 1};">${type}</span>
                        <span class="legend-count">${count}</span>
                    </div>
                `;
            }).join('');

            // æ·»åŠ ç‚¹å‡»äº‹ä»¶
            container.querySelectorAll('.legend-color').forEach(el => {
                el.addEventListener('click', () => {
                    const type = el.parentElement.dataset.type;
                    toggleTypeVisibility(type);
                });
            });
        }

        // === åˆ‡æ¢ç±»å‹å¯è§æ€§ ===
        function toggleTypeVisibility(type) {
            if (hiddenTypes.has(type)) {
                hiddenTypes.delete(type);
            } else {
                hiddenTypes.add(type);
            }

            if (graph && sigmaInstance) {
                graph.forEachNode((nodeId, attrs) => {
                    const isHidden = hiddenTypes.has(attrs.entityType);
                    graph.setNodeAttribute(nodeId, 'hidden', isHidden);
                });

                graph.forEachEdge((edgeId, attrs, source, target) => {
                    const sourceAttrs = graph.getNodeAttributes(source);
                    const targetAttrs = graph.getNodeAttributes(target);
                    const isHidden = hiddenTypes.has(sourceAttrs.entityType) || hiddenTypes.has(targetAttrs.entityType);
                    graph.setEdgeAttribute(edgeId, 'hidden', isHidden);
                });

                sigmaInstance.refresh();
            }

            if (graphData) {
                renderLegend(graphData.entity_types);
            }
        }

        // === æ˜¾ç¤ºèŠ‚ç‚¹è¯¦æƒ… ===
        function showNodeDetail(nodeId, attrs) {
            const container = document.getElementById('detail-content');
            container.innerHTML = `
                <div class="detail-field">
                    <div class="detail-label">èŠ‚ç‚¹ID</div>
                    <div class="detail-value">${cleanNodeId(nodeId)}</div>
                </div>
                <div class="detail-field">
                    <div class="detail-label">å®ä½“ç±»å‹</div>
                    <div class="detail-value">
                        <span class="entity-type-badge" style="background: ${getTypeColor(attrs.entityType)}; color: white;">
                            ${attrs.entityType || 'æœªçŸ¥'}
                        </span>
                    </div>
                </div>
                <div class="detail-field">
                    <div class="detail-label">æè¿°</div>
                    <div class="detail-value">${attrs.description || 'æ— æè¿°'}</div>
                </div>
            `;
        }

        // === æ˜¾ç¤ºè¾¹è¯¦æƒ… ===
        function showEdgeDetail(source, target, attrs) {
            const container = document.getElementById('detail-content');
            container.innerHTML = `
                <div class="detail-field">
                    <div class="detail-label">å…³ç³»</div>
                    <div class="detail-value">${cleanNodeId(source)} â€” ${cleanNodeId(target)}</div>
                </div>
                <div class="detail-field">
                    <div class="detail-label">æè¿°</div>
                    <div class="detail-value">${attrs.description || 'æ— æè¿°'}</div>
                </div>
            `;
        }

        // === æœç´¢åŠŸèƒ½ ===
        let searchTimeout;

        async function handleSearch(query) {
            const resultsContainer = document.getElementById('search-results');

            if (!query.trim()) {
                resultsContainer.classList.remove('show');
                return;
            }

            try {
                const resp = await fetch(`/api/graph/search?q=${encodeURIComponent(query)}`);
                const data = await resp.json();

                if (data.success && data.results.length > 0) {
                    resultsContainer.innerHTML = data.results.map(r => {
                        const safeId = r.id.replace(/"/g, '&quot;');
                        return `
                            <div class="search-result-item" data-id="${safeId}">
                                <span class="entity-type-badge" style="background: ${getTypeColor(r.entity_type)}; color: white; font-size: 10px;">
                                    ${r.entity_type}
                                </span>
                                <div style="margin-top: 6px; font-size: 13px;">${cleanNodeId(r.id)}</div>
                            </div>
                        `;
                    }).join('');

                    resultsContainer.querySelectorAll('.search-result-item').forEach(item => {
                        item.addEventListener('click', () => {
                            const nodeId = item.dataset.id;
                            focusNode(nodeId);
                            resultsContainer.classList.remove('show');
                        });
                    });

                    resultsContainer.classList.add('show');
                } else {
                    resultsContainer.innerHTML = '<div class="search-result-item">æœªæ‰¾åˆ°åŒ¹é…ç»“æœ</div>';
                    resultsContainer.classList.add('show');
                }
            } catch (error) {
                console.error('æœç´¢å¤±è´¥:', error);
            }
        }

        // === èšç„¦èŠ‚ç‚¹ ===
        function focusNode(nodeId) {
            if (!sigmaInstance || !graph.hasNode(nodeId)) return;

            const camera = sigmaInstance.getCamera();
            const nodePos = sigmaInstance.getNodeDisplayData(nodeId);

            if (nodePos) {
                camera.animate({ x: nodePos.x, y: nodePos.y, ratio: 0.1 }, { duration: 500 });
                selectNode(nodeId);
            }
        }

        // === åˆå§‹åŒ– ===
        document.addEventListener('DOMContentLoaded', () => {
            loadGraph();

            // æœç´¢
            document.getElementById('search-input').addEventListener('input', (e) => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => handleSearch(e.target.value), 300);
            });

            // ç‚¹å‡»å…¶ä»–åœ°æ–¹å…³é—­æœç´¢
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.search-box')) {
                    document.getElementById('search-results').classList.remove('show');
                }
            });

            // æ˜¾ç¤ºæ ‡ç­¾å¼€å…³
            document.getElementById('show-labels').addEventListener('change', (e) => {
                if (sigmaInstance) {
                    sigmaInstance.setSetting('renderLabels', e.target.checked);
                }
            });

            // ç¼©æ”¾æ§åˆ¶
            document.getElementById('zoom-in').addEventListener('click', () => {
                if (sigmaInstance) {
                    const camera = sigmaInstance.getCamera();
                    camera.animate({ ratio: camera.ratio / 1.5 }, { duration: 200 });
                }
            });

            document.getElementById('zoom-out').addEventListener('click', () => {
                if (sigmaInstance) {
                    const camera = sigmaInstance.getCamera();
                    camera.animate({ ratio: camera.ratio * 1.5 }, { duration: 200 });
                }
            });

            document.getElementById('zoom-reset').addEventListener('click', () => {
                if (sigmaInstance) {
                    const camera = sigmaInstance.getCamera();
                    camera.animate({ x: 0.5, y: 0.5, ratio: 1 }, { duration: 500 });
                }
            });

            // === æ£€ç´¢åŠŸèƒ½ ===
            const retrieveInput = document.getElementById('retrieve-input');
            const retrieveBtn = document.getElementById('retrieve-btn');
            const clearRetrieveBtn = document.getElementById('clear-retrieve-btn');

            async function performRetrieval() {
                const query = retrieveInput.value.trim();
                if (!query) return;

                retrieveBtn.textContent = 'æ£€ç´¢ä¸­...';
                retrieveBtn.disabled = true;

                try {
                    const resp = await fetch(`/api/graph/retrieve?q=${encodeURIComponent(query)}`);
                    const data = await resp.json();

                    if (data.success && data.nodes && data.nodes.length > 0) {
                        highlightSubgraph(data.nodes, data.edges || [], data.scores || {});
                        clearRetrieveBtn.style.display = 'block';

                        // æ˜¾ç¤ºæ£€ç´¢ç»“æœä¿¡æ¯
                        document.getElementById('detail-content').innerHTML = `
                            <div class="detail-field">
                                <div class="detail-label">æ£€ç´¢ç»“æœ</div>
                                <div class="detail-value">æ‰¾åˆ° ${data.nodes.length} ä¸ªç›¸å…³èŠ‚ç‚¹</div>
                            </div>
                            <div class="detail-field">
                                <div class="detail-label">æŸ¥è¯¢</div>
                                <div class="detail-value">${query}</div>
                            </div>
                        `;
                    } else {
                        alert(data.message || data.error || 'æœªæ‰¾åˆ°ç›¸å…³èŠ‚ç‚¹');
                    }
                } catch (error) {
                    console.error('æ£€ç´¢å¤±è´¥:', error);
                    alert('æ£€ç´¢å¤±è´¥: ' + error.message);
                } finally {
                    retrieveBtn.textContent = 'æ£€ç´¢';
                    retrieveBtn.disabled = false;
                }
            }

            // é«˜äº®å­å›¾
            function highlightSubgraph(nodeIds, edges, scores) {
                if (!graph || !sigmaInstance) return;

                const nodeSet = new Set(nodeIds);
                console.log("Retrieval nodes:", nodeIds);
                console.log("Graph nodes sample:", graph.nodes().slice(0, 5));

                let matchedCount = 0;

                // ä¿å­˜åŸå§‹å±æ€§å¹¶æ·¡åŒ–æ‰€æœ‰èŠ‚ç‚¹
                graph.forEachNode((nodeId, attrs) => {
                    if (!originalNodeAttrs[nodeId]) {
                        originalNodeAttrs[nodeId] = {
                            size: attrs.size,
                            color: attrs.color,
                            label: attrs.label
                        };
                    }

                    if (nodeSet.has(nodeId)) {
                        matchedCount++;
                        // æ£€ç´¢åˆ°çš„èŠ‚ç‚¹ï¼šé«˜äº®ã€æ”¾å¤§ï¼Œä¿æŒåŸè‰²ï¼ˆä¸é€‰ä¸­é€»è¾‘ä¸€è‡´ï¼‰
                        const highlightSize = Math.max((attrs.originalSize || attrs.size) * 2, 10);
                        graph.setNodeAttribute(nodeId, 'size', highlightSize);
                        // ä½¿ç”¨ä¿å­˜çš„åŸå§‹é¢œè‰²ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨å½“å‰å±æ€§ä¸­çš„ color æˆ– originalColor
                        const originalColor = originalNodeAttrs[nodeId]?.color || attrs.originalColor || attrs.color;
                        graph.setNodeAttribute(nodeId, 'color', originalColor);
                        graph.setNodeAttribute(nodeId, 'zIndex', 1000);
                        graph.setNodeAttribute(nodeId, 'label', cleanNodeId(nodeId));
                    } else {
                        // å…¶ä»–èŠ‚ç‚¹ï¼šæ·¡åŒ–
                        graph.setNodeAttribute(nodeId, 'color', '#3d3654');
                        graph.setNodeAttribute(nodeId, 'label', '');
                        graph.setNodeAttribute(nodeId, 'zIndex', 0);
                    }
                });

                console.log("Matched nodes:", matchedCount, "of", nodeIds.length);

                // æ·¡åŒ–/é«˜äº®è¾¹
                graph.forEachEdge((edgeId, attrs, source, target) => {
                    if (nodeSet.has(source) && nodeSet.has(target)) {
                        // ä¸¤ç«¯éƒ½åœ¨ç»“æœä¸­çš„è¾¹ï¼šé«˜äº®
                        const sourceColor = originalNodeAttrs[source]?.color || attrs.originalColor;
                        graph.setEdgeAttribute(edgeId, 'color', sourceColor || '#a78bfa');
                        graph.setEdgeAttribute(edgeId, 'size', 3);
                        graph.setEdgeAttribute(edgeId, 'zIndex', 500);
                    } else {
                        // å…¶ä»–è¾¹ï¼šæ·¡åŒ–
                        graph.setEdgeAttribute(edgeId, 'color', '#2d2644');
                        graph.setEdgeAttribute(edgeId, 'size', 0.5);
                        graph.setEdgeAttribute(edgeId, 'zIndex', 0);
                    }
                });

                sigmaInstance.refresh();

                // æ›´æ–°è¯¦æƒ…é¢æ¿æ˜¾ç¤ºåŒ¹é…æƒ…å†µ
                if (matchedCount === 0 && nodeIds.length > 0) {
                    document.getElementById('detail-content').innerHTML += `
                        <div class="detail-field" style="color: #fbbf24;">
                            <div class="detail-label">è­¦å‘Š</div>
                            <div class="detail-value">èŠ‚ç‚¹IDæ ¼å¼å¯èƒ½ä¸åŒ¹é…ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°æ—¥å¿—</div>
                        </div>
                    `;
                }
            }

            retrieveBtn.addEventListener('click', performRetrieval);
            retrieveInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') performRetrieval();
            });

            clearRetrieveBtn.addEventListener('click', () => {
                clearSelection();
                clearRetrieveBtn.style.display = 'none';
                retrieveInput.value = '';
                document.getElementById('detail-content').innerHTML =
                    '<div style="color: var(--text-tertiary);">ç‚¹å‡»èŠ‚ç‚¹æˆ–è¾¹æŸ¥çœ‹è¯¦æƒ…</div>';
            });
        });
    </script>
</body>

</html>